# name: test/sql/html_complex_types.test
# description: Test complex nested types for read_html (feature parity with read_xml)
# group: [sql]

require webbed

# Test 1: Verify nested STRUCT types are inferred correctly
# Note: Column order is non-deterministic, so we order by column name
# The section elements have two different schemas that are now correctly merged:
# - section[1] has address child
# - section[2] has skill-item child
# Both children are now included in the inferred schema (Issue #47 FIXED)
query TTTTTT
SELECT * FROM (DESCRIBE SELECT * FROM read_html('test/html/complex_types_test.html', record_element:='article', attr_mode:='discard')) ORDER BY column_name;
----
header	STRUCT("employee-id" INTEGER, "full-name" VARCHAR)	YES	NULL	NULL	NULL
section	STRUCT(address STRUCT("street-address" VARCHAR, "city-name" VARCHAR, "zip-code" INTEGER, "phone-numbers" STRUCT("phone-number" VARCHAR[])), "skill-item" VARCHAR[])[]	YES	NULL	NULL	NULL

# Test 2: Access nested struct fields
query III
SELECT
    header."employee-id" as id,
    header."full-name" as name,
    section[1].address."city-name" as city
FROM read_html('test/html/complex_types_test.html', record_element:='article', attr_mode:='discard')
ORDER BY header."employee-id";
----
1	Alice Johnson	Portland
2	Bob Smith	Seattle

# Test 3: Access deeply nested phone numbers (now returns array after cross-record fix)
query II
SELECT
    header."employee-id" as id,
    section[1].address."phone-numbers"."phone-number" as phones
FROM read_html('test/html/complex_types_test.html', record_element:='article', attr_mode:='discard')
WHERE header."employee-id" = 1;
----
1	[555-1234, 555-5678]

# Test 4: Access skill-item from heterogeneous section (Issue #47 FIXED)
query II
SELECT
    header."employee-id" as id,
    section[2]."skill-item" as skills
FROM read_html('test/html/complex_types_test.html', record_element:='article', attr_mode:='discard')
ORDER BY header."employee-id";
----
1	[Python, SQL, DuckDB]
2	[Java, C++]

# Test 5: Unnest skills from heterogeneous section (Issue #47 FIXED)
query II
SELECT
    header."employee-id" as id,
    unnest(section[2]."skill-item") as skill
FROM read_html('test/html/complex_types_test.html', record_element:='article', attr_mode:='discard')
WHERE header."employee-id" = 1
ORDER BY skill;
----
1	DuckDB
1	Python
1	SQL

# Test 6: Verify array lengths work for phone numbers
query II
SELECT
    header."employee-id" as id,
    array_length(section[1].address."phone-numbers"."phone-number") as phone_count
FROM read_html('test/html/complex_types_test.html', record_element:='article', attr_mode:='discard')
ORDER BY header."employee-id";
----
1	2
2	1

# Test 7: Test with all_varchar - nested structures should remain as STRUCT but scalars become VARCHAR
# With cross-record fix, phone-number is now VARCHAR[] as expected
# With Issue #47 fix, skill-item is now in schema
query TTTTTT
SELECT * FROM (DESCRIBE SELECT * FROM read_html('test/html/complex_types_test.html', record_element:='article', all_varchar:=true, attr_mode:='discard')) ORDER BY column_name;
----
header	STRUCT("employee-id" VARCHAR, "full-name" VARCHAR)	YES	NULL	NULL	NULL
section	STRUCT(address STRUCT("street-address" VARCHAR, "city-name" VARCHAR, "zip-code" VARCHAR, "phone-numbers" STRUCT("phone-number" VARCHAR[])), "skill-item" VARCHAR[])[]	YES	NULL	NULL	NULL
